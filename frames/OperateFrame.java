/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package frames;

import abonentgaz.CSVOperate;
import java.awt.Cursor;
import java.io.File;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.ListSelectionModel;
import javax.swing.filechooser.FileFilter;
import javax.swing.table.DefaultTableModel;
import runqueries.Runquery;

/**
 *
 * @author lera
 */
public class OperateFrame extends javax.swing.JFrame {
    private MDIObject parentFrame;
    private int idOperation;// идентификатор операций (импорт, экспорт, обновление)
    private DBOperation dbOperate;
//    private JDBCConnection connect;
//    private String nameTable;// имя выбранной таблицы
    
    /**
     * Creates new form OperateFrame
     */
    public OperateFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        OptionDialog = new javax.swing.JDialog();
        chkHeader = new javax.swing.JCheckBox();
        jPanel1 = new javax.swing.JPanel();
        CommaRadioBtn = new javax.swing.JRadioButton();
        CommaPointRadioBtn = new javax.swing.JRadioButton();
        TwinPointRadioBtn = new javax.swing.JRadioButton();
        YesButton = new javax.swing.JButton();
        buttonGroup1 = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jToolBar1 = new javax.swing.JToolBar();
        btnOpenFile = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        lstTableName = new javax.swing.JList();
        jScrollPane2 = new javax.swing.JScrollPane();
        lstTargetList = new javax.swing.JList();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        btnPreviouse = new javax.swing.JButton();
        btnNext = new javax.swing.JButton();
        OKButton = new javax.swing.JButton();
        btnSendTo = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtStep = new javax.swing.JTextArea();
        OperateProgressBar = new javax.swing.JProgressBar();

        OptionDialog.setModal(true);

        chkHeader.setSelected(true);
        chkHeader.setText("В первой строке заголовки столбцов");

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Разделитель полей"));

        buttonGroup1.add(CommaRadioBtn);
        CommaRadioBtn.setText("Запятая");

        buttonGroup1.add(CommaPointRadioBtn);
        CommaPointRadioBtn.setSelected(true);
        CommaPointRadioBtn.setText("Точка с запятой");

        buttonGroup1.add(TwinPointRadioBtn);
        TwinPointRadioBtn.setText("Двоеточие");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(CommaRadioBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(CommaPointRadioBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TwinPointRadioBtn)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(CommaRadioBtn)
                    .addComponent(CommaPointRadioBtn)
                    .addComponent(TwinPointRadioBtn))
                .addGap(26, 26, 26))
        );

        YesButton.setText("ОК");
        YesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout OptionDialogLayout = new javax.swing.GroupLayout(OptionDialog.getContentPane());
        OptionDialog.getContentPane().setLayout(OptionDialogLayout);
        OptionDialogLayout.setHorizontalGroup(
            OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, OptionDialogLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(OptionDialogLayout.createSequentialGroup()
                .addGroup(OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(OptionDialogLayout.createSequentialGroup()
                        .addGap(123, 123, 123)
                        .addComponent(YesButton))
                    .addGroup(OptionDialogLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(chkHeader)))
                .addGap(0, 0, Short.MAX_VALUE))
        );
        OptionDialogLayout.setVerticalGroup(
            OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(OptionDialogLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(chkHeader)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(YesButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentHidden(java.awt.event.ComponentEvent evt) {
                formComponentHidden(evt);
            }
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        jLabel1.setText("jLabel1");

        jToolBar1.setRollover(true);

        btnOpenFile.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/OpenFile.png"))); // NOI18N
        btnOpenFile.setText("открыть");
        btnOpenFile.setToolTipText("открыть файл");
        btnOpenFile.setFocusable(false);
        btnOpenFile.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        btnOpenFile.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        btnOpenFile.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        btnOpenFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOpenFileActionPerformed(evt);
            }
        });
        jToolBar1.add(btnOpenFile);

        jLabel2.setText("jLabel2");

        jScrollPane1.setViewportView(lstTableName);

        lstTargetList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane2.setViewportView(lstTargetList);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        jTable1.setCellSelectionEnabled(true);
        jTable1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        jScrollPane3.setViewportView(jTable1);

        btnPreviouse.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/NavBack.png"))); // NOI18N
        btnPreviouse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPreviouseActionPerformed(evt);
            }
        });

        btnNext.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/NavForward.png"))); // NOI18N
        btnNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNextActionPerformed(evt);
            }
        });

        OKButton.setText("Отмена");
        OKButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OKButtonActionPerformed(evt);
            }
        });

        btnSendTo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/NavForward.png"))); // NOI18N
        btnSendTo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendToActionPerformed(evt);
            }
        });

        jScrollPane4.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        txtStep.setBackground(new java.awt.Color(212, 208, 200));
        txtStep.setColumns(20);
        txtStep.setFont(new java.awt.Font("Tahoma", 0, 11)); // NOI18N
        txtStep.setLineWrap(true);
        txtStep.setRows(5);
        txtStep.setWrapStyleWord(true);
        txtStep.setFocusable(false);
        jScrollPane4.setViewportView(txtStep);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnSendTo, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnPreviouse)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnNext)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(OKButton))
                    .addComponent(jScrollPane4)
                    .addComponent(OperateProgressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
            .addComponent(jScrollPane3)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(13, 13, 13)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(OperateProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(11, 11, 11)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnPreviouse)
                            .addComponent(btnNext)
                            .addComponent(OKButton)))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel2)
                                .addComponent(jLabel1))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(btnSendTo)
                            .addGap(51, 51, 51))))
                .addGap(8, 8, 8)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 222, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        // блокируем доступ к главному окну приложения
//        connect = parentFrame.getConnect();
        parentFrame.setEnabled(false);
//        OperateProgressBar.setVisible(false);
        OperateProgressBar.setValue(0);
        
        // задаём заголовок фрейма
        setFrameTitle();
        
        try {
            dbOperate = new DBOperation();
            btnPreviouse.doClick();
            
        } catch(java.lang.Exception ex){
        }
    }//GEN-LAST:event_formComponentShown

    private void formComponentHidden(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentHidden
        // снимаем блокировку с главного окна приложения
        parentFrame.setEnabled(true);
        
    }//GEN-LAST:event_formComponentHidden

    private void btnNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNextActionPerformed
        // следующий шаг операции
        dbOperate.moveNext();
        // запрещаем доступ к выполнению следующего шага
        btnNext.setEnabled(false);
    }//GEN-LAST:event_btnNextActionPerformed

    private void btnPreviouseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPreviouseActionPerformed
        // предыдущий шаг операции
        dbOperate.movePreviouse();
        btnNext.setEnabled(false);
    }//GEN-LAST:event_btnPreviouseActionPerformed

    private void btnSendToActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendToActionPerformed
        // если есть выделенный элемент в левом списке
        // переносим его в правый список
        if(lstTableName.getSelectedIndices().length > 0){
            dbOperate.addListItem();
            
            // разрешаем доступ к выполнению следующего шага
            btnNext.setEnabled(true);
        }
    }//GEN-LAST:event_btnSendToActionPerformed

    private void OKButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OKButtonActionPerformed
        // выполняем следующий шаг в операции с базой
        dbOperate.moveNext();
    }//GEN-LAST:event_OKButtonActionPerformed

    private void btnOpenFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOpenFileActionPerformed
        // отображаем окно выбора файла
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File("."));
        chooser.setMultiSelectionEnabled(false);// множественныый выбор запрещён
        // фильтр файлов по формату
        FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File f) {
                return f.getName().toLowerCase().endsWith(".csv") || 
                        f.getName().toLowerCase().endsWith(".txt") || 
                        f.isDirectory();
            }

            @Override
            public String getDescription() {
                return "Текстовые файлы с разделителями (*.csv,*.txt)";
            }
        };
        chooser.setFileFilter(filter);// устанавливаем фильтр для окна выбора файла
        int result = chooser.showOpenDialog(this);
        
        // если пользователь выбрал файл, то отображаем его название в заголовке
        if(result == JFileChooser.APPROVE_OPTION){
            // устанавливаем заголовок окна в ихсодное состояние
            setFrameTitle();
            
            String name;
            try {
                name = chooser.getSelectedFile().getCanonicalPath();
                System.out.println("file - " + name);
                
                setTitle(getTitle() + " : " + name);
                // окно дополнительных параметров файла
                OptionDialog.setSize(305, 147);
                OptionDialog.setLocation(parentFrame.centerPoint(OptionDialog.getWidth(), 
                        OptionDialog.getHeight()));
                OptionDialog.setVisible(true);
                String separator;
                // проверем выбор пользователя
                CSVOperate csvReader = new CSVOperate();
                csvReader.setFileName(name);
                csvReader.setHeader(chkHeader.isSelected());// есть ли заголовки
                if(CommaRadioBtn.isSelected()){
                    separator = ",";
                } else if(CommaPointRadioBtn.isSelected()){
                    separator = ";";
                } else {
                    separator = ":";
                }
                csvReader.setSeparator(separator);
                csvReader.readData();
                
                // получаем модель данных для таблицы
                DefaultTableModel model = new DefaultTableModel(csvReader.getData(), 
                        csvReader.getColumnName());
                jTable1.setModel(model);
            } catch (IOException ex) {
                Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        }
    }//GEN-LAST:event_btnOpenFileActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        // скрываем диалоговое окно дополнительных настроек
        OptionDialog.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(OperateFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            @Override
            public void run() {
                new OperateFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton CommaPointRadioBtn;
    private javax.swing.JRadioButton CommaRadioBtn;
    private javax.swing.JButton OKButton;
    private javax.swing.JProgressBar OperateProgressBar;
    private javax.swing.JDialog OptionDialog;
    private javax.swing.JRadioButton TwinPointRadioBtn;
    private javax.swing.JButton YesButton;
    private javax.swing.JButton btnNext;
    private javax.swing.JButton btnOpenFile;
    private javax.swing.JButton btnPreviouse;
    private javax.swing.JButton btnSendTo;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JCheckBox chkHeader;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTable jTable1;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JList lstTableName;
    private javax.swing.JList lstTargetList;
    private javax.swing.JTextArea txtStep;
    // End of variables declaration//GEN-END:variables

    /**
     * @param parentFrame the parentFrame to set
     */
    public void setParentFrame(MDIObject parentFrame) {
        this.parentFrame = parentFrame;
    }
    
    /**
     * @param idOperation the idOperation to set
     */
    public void setIdOperation(int idOperation) {
        this.idOperation = idOperation;
        // название кнопки
        switch (idOperation) {
            case 0:
                OKButton.setText("Импорт");
                break;
            case 1:
                OKButton.setText("Экспорт");
                break;
            default:
                OKButton.setText("Обновить");
                break;
        }
        OKButton.setEnabled(false);// делаем её недоступной
    }
    
    /**
     * устанавливает заголовок окна
     */
    private void setFrameTitle(){
        switch (idOperation) {
            case 0:
                setTitle("Импорт данных");
                break;
            case 1:
                setTitle("Экспорт данных");
                break;
            default:
                setTitle("Обновление данных");
                break;
        }
    }
    
    /**
     * обеспечивает проведение операций импорта, экспорта и 
     * обновления базы данных
     */
    private class DBOperation {
        private Object[] table_Name;// массив с именами таблиц базы данных
        private Object[] column_Name;// массив с именами полей выбранной таблицы
        private int step = 0;// номер шага для выбранной операции с базой данных
        private String[] nameItem;// имена выбранных полей
        private String[] column;
        private final int importStep = 4;// количество шагов для операции импорта
        private final int exportStep = 3;// количество шагов для операции экспорта
        private final int updateStep = 5;// количество шагов для операции обновления
        private String table;// имя выбранной таблицы
        private DefaultListModel model;
        private String keyColumn;// имя ключевого поля для обновления данных

        public DBOperation(){
            executeOperation();
        }

        /**
        * устанавливает модель для списка
        */
        private void setListModel(JList list, Object[] nameArray){
            model = new DefaultListModel();
            model.clear();
    //        list.removeSelectionInterval(0, list.getModel().getSize());
            list.setModel(model);// очищаем список
            // если передан массив и он содержит данные
            if(nameArray != null && nameArray.length > 0){
                for (Object nameArray1 : nameArray) {
                    model.addElement(nameArray1.toString());
                }
                list.setModel(model);
            }
        }

        /**
        * следующий шаг выбранной операции
        */
        public void moveNext(){
            // перед перемещением на следующий шаг сравниваем его значение с 
            // заданным количеством шагов
            int count = 0;
            switch(idOperation){
                case 0:// импорт
                    count = importStep;
                    break;
                case 1:// экспорт
                    count = exportStep;
                    break;
                case 2:// обновление
                    count = updateStep;
                    break;
            }
            // увеличиваем шаг
            step++;
            if(step <= count){
                executeOperation();
            } else{
                step--;
                }
        }

        /**
        * предыдущий шаг выбранной операции
        */
        public void movePreviouse(){
            // уменьшаем шаг
            step--;
            if(step >= 0){

                executeOperation();
            } else{
                step = 0;
            }
        }

        /**
        * выполнение выбранного шага операции
        */
        private void executeOperation(){
            switch(idOperation){
                case 0:// импорт
                    importData();
                    break;
                case 1:// экспорт
                    exportData();
                    break;
                case 2:// обновление
                    updateData();
                    break;
            }
        }

        /**
        * операция импорта данных
        */
        private void importData(){
            OKButton.setEnabled(false);
    //        OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:// перечень таблиц базы данных
                    try {
                        getDBTableName();

                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 1: выберите таблицу для импорта данных");
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля, в которые будут импортироваться" +
                            " данные");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:// перечень полей с данными
                    // заполняем список полями данных
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTableName, nameItem);
                    setListModel(lstTargetList, column);
                    // запрещаем множественное выделение
                    lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                    txtStep.setText("Шаг 3: выберите поля, из которых будут импортироваться" +
                            " данные, и соответствующие им поля из правого списка");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 3:
                    txtStep.setText("Шаг 4: нажмите Импорт для импорта данных");
                    OKButton.setEnabled(true);
                    break;
                case 4:
                    OperateProgressBar.setVisible(true);
                    txtStep.setText("Выполняется импорт данных. Ожидайте...");
                    int counter = importDataToDB();
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText(text + "Выполнен импорт данных в количестве " + counter);

                    break;
            }
        }

        /**
        * операция экспорта данных
        */
        private void exportData(){
            OKButton.setEnabled(false);
            OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:
                    try {
                        getDBTableName();// выводим список таблиц
                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 1: выберите таблицу для экспорта данных");
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля, из которых будут " +
                            "экспортироваться данные");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:
                    // получаем данные для экспорта
                    getDataFromDBTable();
                    txtStep.setText("Шаг 3: нажмите Экспорт для экспорта данных");
                    OKButton.setEnabled(true);
                    break;
                case 3:
                    int count = 0;
                    OperateProgressBar.setVisible(true);
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText(text + "Выполнен экспорт данных в количестве " + count);
                    break;
            }
        }

        /**
        * операция обновления данных
        */
        private void updateData(){
            OKButton.setEnabled(false);
    //        OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:
                    try {
                        getDBTableName();
                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    txtStep.setText("Шаг 1: выберите таблицу для обновления данных");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля для обновления данных");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTargetList, nameItem);
                    txtStep.setText("Шаг 3: выберите ключевое поле для обновления" +
                            " данных из левого списка и соответствующее ему поле из" +
                            " правого списка");
                    jLabel1.setText("список полей");
                    jLabel2.setText("ключевое поле");
                    break;
                case 3:
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTableName, nameItem);
                    setListModel(lstTargetList, column);
                    // запрещаем множественное выделение
                    lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                    txtStep.setText("Шаг 4: выберите поля, из которых будут " +
                            "обновляться данные, и соответствующие " +
                            "им поля для обновления");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 4:
                    txtStep.setText("Шаг 5: нажмите Обновить для обновления данных");
                    OKButton.setEnabled(true);
                    break;
                case 5:
    //                OperateProgressBar.setVisible(true);
                    int update = updateDataDB();
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText( text + "Обновлены данные в количестве " + update);
                    break;

            }
        }

        /**
        * получение списка таблиц базы данных
        */
        private void getDBTableName() throws SQLException{
            table_Name = parentFrame.getConnect().getListTable();
            // устанавливаем модель для списка с именами теблиц
            setListModel(lstTableName, table_Name);
            // запрещаем множественное выделение
            lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        }

        /**
        * получение списка полей выбранной таблицы
        */
        private void getTableColumnName() throws SQLException{
            column_Name = parentFrame.getConnect().getListColumnTable(table);
            setListModel(lstTableName, column_Name);
            // разрешаем множественное выделение
            lstTableName.setSelectionMode(
                    ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);// очищаем список для выбранных полей
            setListModel(lstTargetList, null);
        }

        /**
        *  добавляет элемент в список
        */
        public void addListItem(){
            switch(idOperation){
                case 0:// импорт
                    addListItemImport();
                    break;
                case 1:// экспорт
                    addListItemExport();
                    break;
                case 2:// обновление
                    addListitemUpdate();
                    break;
            }
        }

        private void addListItemImport(){
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
                case 2:// сопоставление полей
                    // индекс выделенного элемента
                    int j = lstTargetList.getSelectedIndex();

                    Object value = lstTargetList.getSelectedValue() +
                            "-" +lstTableName.getSelectedValue();

                    model = new DefaultListModel();// переопределяем модель
                    for(int i = 0; 
                            i < lstTargetList.getModel().getSize(); i++){
                        lstTargetList.setSelectedIndex(i);
                        model.addElement(lstTargetList.getSelectedValue());
                    }

                    model.setElementAt(value, j);// новое значение

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
            }

        }

        private void addListItemExport(){
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
            }
        }

        private void addListitemUpdate() {
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
                case 2:// выбор ключевого поля
                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());

                    // первая часть - ключевое поле для обновления в таблице
                    // вторая часть - сопоставленное ему поле в массиве данных,
                    // значение которого будет использоваться для идентификации ключевого поля
                    keyColumn = lstTableName.getSelectedValue().toString() +
                            "-" + lstTargetList.getSelectedValue().toString();
                    System.out.println("keyColumn -" + keyColumn);
                    break;
                case 3:// сопоставление полей
                    // индекс выделенного элемента
                    int j = lstTargetList.getSelectedIndex();

                    Object value = lstTargetList.getSelectedValue() +
                            "-" +lstTableName.getSelectedValue();

                    model = new DefaultListModel();// переопределяем модель
                    for(int i = 0; 
                            i < lstTargetList.getModel().getSize(); i++){
                        lstTargetList.setSelectedIndex(i);
                        model.addElement(lstTargetList.getSelectedValue());
                    }

                    model.setElementAt(value, j);// новое значение

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
            }
        }

        private int importDataToDB(){
            // изменяем вид курсора на песочные часы
    //        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();

            // перебираем строки в правом списке полей,
            // используя символ-разделитель "-", и заполняем ими соответствующие массивы
            int row = lstTargetList.getModel().getSize();// количество элементов
            String[] leftCols = new String[row];// список выбранных полей таблицы БД
            String[] rightCols = new String[row];// список импортируемых полей
            int[] colIndex = new int[row];// индекы столбцов таблицы
            ArrayList error = new ArrayList();// массив ошибочных записей
            // заполняем массивы полей
            for(int i = 0; i < row; i++){
                lstTargetList.setSelectedIndex(i);// выделяем элемент списка
                int pos = lstTargetList.getSelectedValue().toString().indexOf("-");
                leftCols[i] = lstTargetList.getSelectedValue().toString().substring(0, pos);
                rightCols[i] = lstTargetList.getSelectedValue().toString().substring(pos + 1);
                // получаем индекс столбца по имени
                for(int j = 0; j < jTable1.getColumnCount(); j++){
                    if(rightCols[i].equals(jTable1.getColumnName(j))){
                        colIndex[i] = j;
    //                    System.out.println(colIndex[i]);
                        break;// прерываем цикл
                    }
                }
            }
            String sqlQuery;// строка-запрос на добавление записи
            String listfield = "";
            int retval = 0;
            for (String leftCol : leftCols) {
                listfield = listfield + leftCol + ",";
            }
            String fields = listfield.substring(0, listfield.length()-1);
            OperateProgressBar.setValue(0);
            for(int i = 0; i < rowCount; i++){
                // получаем список значений для вставки
                String listvalues = "";
                for(int j = 0; j < colIndex.length; j++){
    //                System.out.println(colIndex[j]);
                    String value = parentFrame.getConnect().getCellValue(leftCols[j],
                            jTable1.getValueAt(i, colIndex[j]).toString());
                    listvalues = listvalues + value + ",";
                }
                String values = listvalues.substring(0, listvalues.length() - 1);
                sqlQuery = "INSERT INTO " + table + "(" + fields + ")" +
                        " VALUES(" + values + ");";
                int count = 0;
                    try {
    //                    System.out.println(sqlQuery);
                        count = parentFrame.getConnect().ExecuteUpdate(sqlQuery);
                    } catch (SQLException ex) {
                        error.add("Ошибка в строке " + (i + 1) +
                                " : код-" + ex.getErrorCode() + "\n\r" +
                                ex.getMessage() + "\n\r");
                    }
                retval = retval + count;
                // определяем процент выполнения
                int percent = (int)(retval * 100) / rowCount;
    //            System.out.println("percent = " + percent);
                OperateProgressBar.setValue(percent);
            }
            // проверяем наличие сообщений в массиве ошибок
            if(error.isEmpty()){
                // если массив ошибок пуст
                txtStep.setText("Ошибки не обнаружены");
            }else{
                String text = "";
                for(int i = 0; i < error.size(); i++)
                    text = text + error.get(i).toString();
                txtStep.setText(text);
            }
            OperateProgressBar.setVisible(false);
    //        setCursor(Cursor.getDefaultCursor());// возвращаем исходный вид курсора
            return retval;
        }

        /**
        * обновление данных в выбранной таблице базы данных
        */
        private int updateDataDB(){
            int retval = 0;
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();

            // позиция разделителя в наименовании ключевого поля
            int pos = keyColumn.indexOf("-");

            // получаем наименования ключевых полей
            String tbKey = keyColumn.substring(0, pos);
            String targetKey= keyColumn.substring(pos + 1, keyColumn.length());

            // получаем индекс ключевого поля в таблице-источнике данных
            int Index = 0;
            for(int j = 0; j < jTable1.getColumnCount(); j++){
                if(targetKey.equals(jTable1.getColumnName(j))){
                    Index = j;
                    break;
                }
            }
            // перебираем строки в правом списке полей,
            // используя символ-разделитель "-", и заполняем ими соответствующие массивы
            int row = lstTargetList.getModel().getSize();// количество элементов
            String[] leftCols = new String[row];// список выбранных полей таблицы БД
            String[] rightCols = new String[row];// список импортируемых полей
            int[] colIndex = new int[row];// индекы столбцов таблицы
            ArrayList error = new ArrayList();// массив ошибочных записей
            // заполняем массивы полей
            for(int i = 0; i < row; i++){
                lstTargetList.setSelectedIndex(i);// выделяем элемент списка
                pos = lstTargetList.getSelectedValue().toString().indexOf("-");
                leftCols[i] = lstTargetList.getSelectedValue().toString().substring(0, pos);
                rightCols[i] = lstTargetList.getSelectedValue().toString().substring(pos + 1);
                // получаем индекс столбца по имени
                for(int j = 0; j < jTable1.getColumnCount(); j++){
                    if(rightCols[i].equals(jTable1.getColumnName(j))){
                        colIndex[i] = j;
    //                    System.out.println(colIndex[i]);
                        break;// прерываем цикл
                    }
                }
            }
            OperateProgressBar.setValue(0);
            String sqlQuery;// строка-запрос на добавление записи
            for(int i = 0; i < rowCount; i++){
                // получаем список значений для вставки
                String listvalues = "";
                for(int j = 0; j < colIndex.length; j++){
    //                System.out.println(colIndex[j]);
                    String value = parentFrame.getConnect().getCellValue(leftCols[j],
                            jTable1.getValueAt(i, colIndex[j]).toString());
                    listvalues = listvalues + leftCols[j] + "=" + value + ",";
                }
                // удаляем последний символ ","
                String values = listvalues.substring(0, listvalues.length() - 1);
                sqlQuery = "UPDATE " + table + " SET " + values + " WHERE " +
                        tbKey + "=" + parentFrame.getConnect().getCellValue(tbKey,
                            jTable1.getValueAt(i, Index).toString()) + ";";
                int count = 0;
                    try {
    //                    System.out.println(sqlQuery);
                        count = parentFrame.getConnect().ExecuteUpdate(sqlQuery);
                    } catch (SQLException ex) {
                        error.add("Ошиба в строке " + (i + 1) + "\n\r" +
                                ex.getMessage() + "\n\r");
                        setCursor(Cursor.getDefaultCursor());// возвращаем исходный вид курсора
                    }
                retval = retval + count;
                // определяем процент выполнения
                int percent = (int)(retval * 100) / rowCount;
    //            System.out.println("percent = " + percent);
                OperateProgressBar.setValue(percent);
            }
            // проверяем наличие сообщений в массиве ошибок
            if(error.isEmpty()){
                // если массив ошибок пуст
                txtStep.setText("Ошибки не обнаружены");
            }else{
                String text = "";
                for(int i = 0; i < error.size(); i++)
                    text = text + error.get(i).toString();
                txtStep.setText(text);
            }
            OperateProgressBar.setVisible(false);
            return retval;
        }

        /**
        * получение данных из выбранной таблицы базы данных
        */
        private void getDataFromDBTable(){
            // получаем перечень полей выбранной таблицы
            String fieldList = "";
            int row = lstTargetList.getModel().getSize();// количество элементов
            for(int i = 0; i < row; i++)
                fieldList = fieldList + lstTargetList.getModel().getElementAt(i).toString() + ",";
            // удаляем последний символ
            String fields = fieldList.substring(0, fieldList.length() - 1);
            // строка-запрос на выборку данных
            String sqlQuery = "SELECT " + fields + " FROM " + table + ";";
//            System.out.println("sqlquery = " + sqlQuery);
//                try {
                    Runquery rq = new Runquery();
                    List<Object[]> resultset = rq.getQueryEntities(sqlQuery);// получаем данные выборки
                    Object[][] content = new Object[resultset.size()][];// задаём размер массива содержимого
                    String[] columnName = rq.getColumnName();// получаем имена столбцов
                    Class[] columnClass = rq.getColumnClass();// получаем типы данных
                    int[] colIndex = new int[columnName.length];
                    for(int i = 0; i < content.length; i++){
                        content[i] = resultset.get(i);// формируем данные для таблицы
                        
                    }
                    for(int i = 0; i < columnName.length; i++)
                        colIndex[i] = i;
//                    DBTableModel tModel = 
//                            new DBTableModel(parentFrame.getConnect().ExecuteQuery(sqlQuery));
//                    DefaultTableModel dtModel = 
//                            new DefaultTableModel(tModel.getContent(), 
//                            tModel.getColumnName());
                    // модель данных для таблицы
                    MyTableModel mtmodel = new MDIObject.MyTableModelImpl(content, columnName, columnClass);
                    MDIObject.fullTableData(colIndex, mtmodel, jTable1);
//                    jTable1.setModel(dtModel);
//                } catch (SQLException ex) {
//                    Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE,
//                            null, ex);
//                }
        }


        private int exportDataFromDB(){
            int retval = 0;
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();
            return retval;
        }

    }

    
}
